// Code generated by protoc-gen-go.
// source: orderer/configuration.proto
// DO NOT EDIT!

package orderer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/hyperledger/fabric/protos/common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ConsensusType struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
}

func (m *ConsensusType) Reset()                    { *m = ConsensusType{} }
func (m *ConsensusType) String() string            { return proto.CompactTextString(m) }
func (*ConsensusType) ProtoMessage()               {}
func (*ConsensusType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type BatchSize struct {
	// Simply specified as number of messages for now, in the future
	// we may want to allow this to be specified by size in bytes
	MaxMessageCount uint32 `protobuf:"varint,1,opt,name=maxMessageCount" json:"maxMessageCount,omitempty"`
	// The byte count of the serialized messages in a batch cannot
	// exceed this value.
	AbsoluteMaxBytes uint32 `protobuf:"varint,2,opt,name=absoluteMaxBytes" json:"absoluteMaxBytes,omitempty"`
	// The byte count of the serialized messages in a batch should not
	// exceed this value.
	PreferredMaxBytes uint32 `protobuf:"varint,3,opt,name=preferredMaxBytes" json:"preferredMaxBytes,omitempty"`
}

func (m *BatchSize) Reset()                    { *m = BatchSize{} }
func (m *BatchSize) String() string            { return proto.CompactTextString(m) }
func (*BatchSize) ProtoMessage()               {}
func (*BatchSize) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type BatchTimeout struct {
	// Any duration string parseable by ParseDuration():
	// https://golang.org/pkg/time/#ParseDuration
	Timeout string `protobuf:"bytes,1,opt,name=timeout" json:"timeout,omitempty"`
}

func (m *BatchTimeout) Reset()                    { *m = BatchTimeout{} }
func (m *BatchTimeout) String() string            { return proto.CompactTextString(m) }
func (*BatchTimeout) ProtoMessage()               {}
func (*BatchTimeout) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

// When submitting a new chain configuration transaction to create a new chain,
// the first configuration item must be of type Orderer with Key CreationPolicy
// and contents of a Marshaled CreationPolicy. The policy should be set to the
// policy which was supplied by the ordering service for the client's chain
// creation. The digest should be the hash of the concatenation of the remaining
// ConfigurationItem bytes. The signatures of the configuration item should
// satisfy the policy for chain creation.
type CreationPolicy struct {
	// The name of the policy which should be used to validate the creation of
	// this chain
	Policy string `protobuf:"bytes,1,opt,name=policy" json:"policy,omitempty"`
	// The hash of the concatenation of remaining configuration item bytes
	Digest []byte `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *CreationPolicy) Reset()                    { *m = CreationPolicy{} }
func (m *CreationPolicy) String() string            { return proto.CompactTextString(m) }
func (*CreationPolicy) ProtoMessage()               {}
func (*CreationPolicy) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

// IngressPolicyNames is the set of policy names which incoming Broadcast signatures are filtered against
type IngressPolicyNames struct {
	// A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
	// because implementing referential policies in a general way is difficult, and dangerous
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *IngressPolicyNames) Reset()                    { *m = IngressPolicyNames{} }
func (m *IngressPolicyNames) String() string            { return proto.CompactTextString(m) }
func (*IngressPolicyNames) ProtoMessage()               {}
func (*IngressPolicyNames) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

// EgressPolicyNames is the set of policy names which incoming Deliver signatures are filtered against
type EgressPolicyNames struct {
	// A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
	// because implementing referential policies in a general way is difficult, and dangerous
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *EgressPolicyNames) Reset()                    { *m = EgressPolicyNames{} }
func (m *EgressPolicyNames) String() string            { return proto.CompactTextString(m) }
func (*EgressPolicyNames) ProtoMessage()               {}
func (*EgressPolicyNames) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

// ChainCreationPolicyNames is the set of policies which may be invoked for chain creation
type ChainCreationPolicyNames struct {
	// A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
	// because implementing referential policies in a general way is difficult, and dangerous
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *ChainCreationPolicyNames) Reset()                    { *m = ChainCreationPolicyNames{} }
func (m *ChainCreationPolicyNames) String() string            { return proto.CompactTextString(m) }
func (*ChainCreationPolicyNames) ProtoMessage()               {}
func (*ChainCreationPolicyNames) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

// Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
// brokers an ordering service
type KafkaBrokers struct {
	// Each broker here should be identified using the (IP|host):port notation,
	// e.g. 127.0.0.1:7050, or localhost:7050 are valid entries
	Brokers []string `protobuf:"bytes,1,rep,name=brokers" json:"brokers,omitempty"`
}

func (m *KafkaBrokers) Reset()                    { *m = KafkaBrokers{} }
func (m *KafkaBrokers) String() string            { return proto.CompactTextString(m) }
func (*KafkaBrokers) ProtoMessage()               {}
func (*KafkaBrokers) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func init() {
	proto.RegisterType((*ConsensusType)(nil), "orderer.ConsensusType")
	proto.RegisterType((*BatchSize)(nil), "orderer.BatchSize")
	proto.RegisterType((*BatchTimeout)(nil), "orderer.BatchTimeout")
	proto.RegisterType((*CreationPolicy)(nil), "orderer.CreationPolicy")
	proto.RegisterType((*IngressPolicyNames)(nil), "orderer.IngressPolicyNames")
	proto.RegisterType((*EgressPolicyNames)(nil), "orderer.EgressPolicyNames")
	proto.RegisterType((*ChainCreationPolicyNames)(nil), "orderer.ChainCreationPolicyNames")
	proto.RegisterType((*KafkaBrokers)(nil), "orderer.KafkaBrokers")
}

func init() { proto.RegisterFile("orderer/configuration.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 346 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x92, 0x5f, 0x6b, 0xa3, 0x40,
	0x14, 0xc5, 0x71, 0xb3, 0x9b, 0x90, 0x4b, 0xb2, 0xbb, 0x99, 0x5d, 0x16, 0xd9, 0xbe, 0x04, 0xfb,
	0x62, 0x43, 0x88, 0x85, 0x7e, 0x81, 0xa2, 0xf4, 0xa1, 0x94, 0x94, 0x62, 0xf3, 0xd4, 0xb7, 0x51,
	0xaf, 0x3a, 0x24, 0xce, 0xc8, 0x9d, 0x11, 0x62, 0xbf, 0x44, 0xbf, 0x72, 0xc9, 0x68, 0x0a, 0x6d,
	0xa0, 0xf4, 0xc9, 0x73, 0xee, 0xf9, 0x39, 0x9c, 0xf9, 0x03, 0x67, 0x8a, 0x32, 0x24, 0xa4, 0x20,
	0x55, 0x32, 0x17, 0x45, 0x43, 0xdc, 0x08, 0x25, 0x57, 0x35, 0x29, 0xa3, 0xd8, 0xa8, 0x0f, 0xff,
	0xff, 0x49, 0x55, 0x55, 0x29, 0x19, 0x74, 0x9f, 0x2e, 0xf5, 0xce, 0x61, 0x1a, 0x29, 0xa9, 0x51,
	0xea, 0x46, 0x6f, 0xda, 0x1a, 0x19, 0x83, 0xef, 0xa6, 0xad, 0xd1, 0x75, 0xe6, 0x8e, 0x3f, 0x8e,
	0xad, 0xf6, 0x5e, 0x1c, 0x18, 0x87, 0xdc, 0xa4, 0xe5, 0xa3, 0x78, 0x46, 0xe6, 0xc3, 0xaf, 0x8a,
	0xef, 0xd7, 0xa8, 0x35, 0x2f, 0x30, 0x52, 0x8d, 0x34, 0x16, 0x9e, 0xc6, 0x1f, 0xc7, 0x6c, 0x01,
	0xbf, 0x79, 0xa2, 0xd5, 0xae, 0x31, 0xb8, 0xe6, 0xfb, 0xb0, 0x35, 0xa8, 0xdd, 0x6f, 0x16, 0x3d,
	0x99, 0xb3, 0x25, 0xcc, 0x6a, 0xc2, 0x1c, 0x89, 0x30, 0x7b, 0x83, 0x07, 0x16, 0x3e, 0x0d, 0x3c,
	0x1f, 0x26, 0xb6, 0xd0, 0x46, 0x54, 0xa8, 0x1a, 0xc3, 0x5c, 0x18, 0x99, 0x4e, 0xf6, 0xc5, 0x8f,
	0xd6, 0xbb, 0x86, 0x9f, 0x11, 0xa1, 0x3d, 0x90, 0x07, 0xb5, 0x13, 0x69, 0xcb, 0xfe, 0xc1, 0xb0,
	0xb6, 0xaa, 0x47, 0x7b, 0x77, 0x98, 0x67, 0xa2, 0x40, 0x6d, 0x6c, 0xc7, 0x49, 0xdc, 0x3b, 0x6f,
	0x01, 0xec, 0x56, 0x16, 0x84, 0x5a, 0x77, 0x0b, 0xdc, 0xf3, 0x0a, 0x35, 0xfb, 0x0b, 0x3f, 0xe4,
	0x41, 0xb8, 0xce, 0x7c, 0xe0, 0x8f, 0xe3, 0xce, 0x78, 0x17, 0x30, 0xbb, 0xf9, 0x22, 0x7a, 0x09,
	0x6e, 0x54, 0x72, 0x21, 0xdf, 0xb7, 0xfb, 0xec, 0x0f, 0x1f, 0x26, 0x77, 0x3c, 0xdf, 0xf2, 0x90,
	0xd4, 0x16, 0x49, 0x1f, 0x36, 0x9d, 0x74, 0xb2, 0xe7, 0x8e, 0x36, 0x5c, 0x3d, 0x2d, 0x0b, 0x61,
	0xca, 0x26, 0x59, 0xa5, 0xaa, 0x0a, 0xca, 0xb6, 0x46, 0xda, 0x61, 0x56, 0x20, 0x05, 0x39, 0x4f,
	0x48, 0xa4, 0x81, 0xbd, 0x7c, 0x1d, 0xf4, 0x4f, 0x23, 0x19, 0x5a, 0x7f, 0xf5, 0x1a, 0x00, 0x00,
	0xff, 0xff, 0x02, 0x01, 0xf1, 0xb0, 0x49, 0x02, 0x00, 0x00,
}
